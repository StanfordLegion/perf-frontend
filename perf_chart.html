<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Legion Performance Testing</title>
  </head>
  <body>

    <div style="width: 100%; height: 450px;">
      <!-- Div is here to avoid reflow when canvas resizes -->
      <canvas id="chart" width="400" height="400"></canvas>
    </div>
    <label for="branch">Branch:</label>
    <select id="branch" disabled><option value="loading">Loading...</option></select>
    <label for="measurement_type">Measurement:</label>
    <select id="measurement_type" disabled><option value="loading">Loading...</option></select>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.bundle.min.js"></script>
    <script>
    // Utility function to fetch JSON.
    var getJSON = function(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open("get", url, true);
      xhr.responseType = "json";
      xhr.onload = function() {
        var status = xhr.status;
        if (status == 200) {
          callback(null, xhr.response);
        } else {
        callback(status);
        }
      };
      xhr.send();
    };

    var make_line_chart = function(data) {
      var ctx = document.getElementById("chart");
      window.line_chart = new Chart(ctx, {
        type: "line",
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          legend: {
            position: "left",
          },
        },
      });
    };

    var update_line_chart_data = function(data) {
      window.line_chart.config.data = data;
      window.line_chart.update();
    };

    // Generate chart data from measurements.
    var get_measurement_data = function(data, branch, measurement_type) {
      var commits = data["commits"][branch];
      var measurements = data["measurements"];
      var data_by_benchmark_argv_host_commit = {};

      var benchmarks = [];
      var argv_by_benchmark = {};
      var host_by_benchmark_argv = {};

      var commit_count = commits.length;
      for (var commit_i = 0; commit_i < commit_count; commit_i++) {
        var commit = commits[commit_i];
        var measurement_count = measurements[commit].length;
        for (var measurement_i = 0; measurement_i < measurement_count; measurement_i++) {
          var measurement = measurements[commit][measurement_i];
          if (measurement["metadata"]["branch"] == branch) {
            var benchmark = measurement["metadata"]["benchmark"];
            var argv = measurement["metadata"]["argv"];
            var host = measurement["metadata"]["host"];

            if (!data_by_benchmark_argv_host_commit[benchmark]) {
              data_by_benchmark_argv_host_commit[benchmark] = {};
              benchmarks.push(benchmark);
              argv_by_benchmark[benchmark] = [];
              host_by_benchmark_argv[benchmark] = {};
            }
            if (!data_by_benchmark_argv_host_commit[benchmark][argv]) {
              data_by_benchmark_argv_host_commit[benchmark][argv] = {};
              argv_by_benchmark[benchmark].push(argv);
              host_by_benchmark_argv[benchmark][argv] = [];
            }
            if (!data_by_benchmark_argv_host_commit[benchmark][argv][host]) {
              data_by_benchmark_argv_host_commit[benchmark][argv][host] = {};
              host_by_benchmark_argv[benchmark][argv].push(host);
            }
            // FIXME: If there are multiple matching entries, this
            // will just pick one. Would be nice to take a mean or
            // something.
            data_by_benchmark_argv_host_commit[benchmark][argv][host][commit] =
              measurement["measurements"][measurement_type];
          }
        }
      }

      var colors = [
        'rgba(255,99,132,1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      var color_count = colors.length;
      var color_i = 0;

      var datasets = [];
      var benchmark_count = benchmarks.length;
      for (var benchmark_i = 0; benchmark_i < benchmark_count; benchmark_i++) {
        var benchmark = benchmarks[benchmark_i];
        var argv_count = argv_by_benchmark[benchmark].length;
        for (var argv_i = 0; argv_i < argv_count; argv_i++) {
          var argv = argv_by_benchmark[benchmark][argv_i];
          var host_count = host_by_benchmark_argv[benchmark][argv].length;
          for (var host_i = 0; host_i < host_count; host_i++) {
            var host = host_by_benchmark_argv[benchmark][argv][host_i];

            var data = [];
            var measurements = data_by_benchmark_argv_host_commit[benchmark][argv][host];
            var commit_count = commits.length;
            for (var commit_i = 0; commit_i < commit_count; commit_i++) {
              var commit = commits[commit_i];
              data.push(measurements[commit]);
            }

            var color = colors[color_i];
            color_i = (color_i + 1) % color_count;

            var dataset = {
              label: benchmark + " / " + argv + " / " + host,
              data: data,
              fill: false,
              pointRadius: 7,
              pointHoverRadius: 10,
              backgroundColor: color,
              borderColor: color,
              borderWidth: 3,
            }
            datasets.push(dataset);
          }
        }
      }

      var labels = [];
      var commit_count = commits.length;
      for (var commit_i = 0; commit_i < commit_count; commit_i++) {
        var commit = commits[commit_i];
        var label = commit.substring(0, 7);
        labels.push(label);
      }

      return {
        labels: labels,
        datasets: datasets,
      };
    };

    var get_measurement_types = function(data) {
      var commits = Object.keys(data["measurements"]);
      var measurements = data["measurements"];

      var measurement_types = [];
      var measurement_types_seen = {};

      var commit_count = commits.length;
      for (var commit_i = 0; commit_i < commit_count; commit_i++) {
        var commit = commits[commit_i];
        var measurement_count = measurements[commit].length;
        for (var measurement_i = 0; measurement_i < measurement_count; measurement_i++) {
          var types = Object.keys(measurements[commit][measurement_i]["measurements"]);
          var types_count = types.length;
          for (var types_i = 0; types_i < types_count; types_i++) {
            var type = types[types_i];
            if (!measurement_types_seen[type]) {
              measurement_types_seen[type] = true;
              measurement_types.push(type);
            }
          }
        }
      }

      return measurement_types;
    };

    var clear_select_options = function(select) {
      for (var i = select.options.length - 1 ; i >= 0 ; i--) {
        select.remove(i);
      }
    };

    var add_select_options = function(select, options) {
      var options_count = options.length;
      for (var i = 0; i < options_count; i++) {
        var option = document.createElement("option");
        option.text = options[i];
        select.add(option);
      }
    };

    var make_branch_picker = function(json_data, current) {
      var branches = json_data["branches"];
      var current_i = branches.indexOf(current);

      var branch_picker = document.getElementById("branch");
      clear_select_options(branch_picker);
      add_select_options(branch_picker, branches);
      branch_picker.selectedIndex = current_i;
      branch_picker.disabled = false;
      branch_picker.addEventListener(
        "change",
        function() {
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type_picker = document.getElementById("measurement_type");
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var make_measurement_type_picker = function(json_data, current) {
      var measurement_types = get_measurement_types(json_data);
      var current_i = measurement_types.indexOf(current);

      var measurement_type_picker = document.getElementById("measurement_type");
      clear_select_options(measurement_type_picker);
      add_select_options(measurement_type_picker, measurement_types);
      measurement_type_picker.selectedIndex = current_i;
      measurement_type_picker.disabled = false;
      measurement_type_picker.addEventListener(
        "change",
        function() {
          var branch_picker = document.getElementById("branch");
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var initialize = function(json_data) {
      // Right now just render the master branch and execution time.
      var branch = "master";
      var measurement_type = "time_seconds";
      var chart_data = get_measurement_data(json_data, branch, measurement_type);
      make_line_chart(chart_data);
      make_branch_picker(json_data, branch);
      make_measurement_type_picker(json_data, measurement_type);
    };

    getJSON("https://raw.githubusercontent.com/StanfordLegion/perf-data/master/rendered/chart.json",
      function(err, data) {
        if (err != null) {
          alert("Error: " + err);
        } else {
          initialize(data);
        }
      });

    </script>
  </body>
</html>
