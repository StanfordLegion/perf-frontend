<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Legion Performance Testing</title>
  </head>
  <body>

    <div style="width: 100%; height: 450px;">
      <!-- Div is here to avoid reflow when canvas resizes -->
      <canvas id="chart" width="400" height="400"></canvas>
    </div>
    <label for="branch">Branch:</label>
    <select id="branch" disabled><option value="loading">Loading...</option></select>
    <label for="measurement_type">Measurement:</label>
    <select id="measurement_type" disabled><option value="loading">Loading...</option></select>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.bundle.min.js"></script>
    <script>
    // A Python defaultdict style map object
    var defaultdict = function(constructor) {
      return new Proxy({}, {
        get: function(target, property) {
          if (!(property in target)) {
            var value = constructor();
            target[property] = value;
          }
          return target[property];
        },
      });
    };

    // Utility function to fetch JSON.
    var getJSON = function(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open("get", url, true);
      xhr.responseType = "json";
      xhr.onload = function() {
        var status = xhr.status;
        if (status == 200) {
          callback(null, xhr.response);
        } else {
        callback(status);
        }
      };
      xhr.send();
    };

    var make_line_chart = function(data) {
      var ctx = document.getElementById("chart");
      window.line_chart = new Chart(ctx, {
        type: "line",
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          legend: {
            position: "left",
          },
        },
      });
    };

    var update_line_chart_data = function(data) {
      window.line_chart.config.data = data;
      window.line_chart.update();
    };

    // Build an index of data points from the JSON data of the form:
    //   branches: [branch]
    //   measurement_types: [measurement_type]
    //   benchmarks: [benchmark]
    //   argvs: [argv]
    //   hosts: [hosts]
    //   commits: [commit] sorted by earliest measurement date
    //   index: branch -> measurement_type -> benchmark -> argv -> host -> commit -> data
    var build_data_index = function(data) {
      var branches = {};
      var measurement_types = {};
      var benchmarks = {};
      var argvs = {};
      var hosts = {};
      var commits = {};
      var data_by_key = defaultdict(function() {  // branch
        return defaultdict(function() {           // measurement_type
          return defaultdict(function() {         // benchmark
            return defaultdict(function() {       // argv
              return defaultdict(function() {     // host
                return defaultdict(function() { return {}; }); // commit -> value
              });
            });
          });
        });
      });

      Object.keys(data.commits).forEach(function(branch) {
        data.commits[branch].forEach(function(commit) {
          data.measurements[commit].forEach(function(measurement) {
            if (measurement.metadata.branch == branch) {
              var benchmark = measurement.metadata.benchmark;
              var argv = measurement.metadata.argv;
              var host = measurement.metadata.host;

              branches[branch] = true;
              benchmarks[benchmark] = true;
              argvs[argv] = true;
              hosts[host] = true;

              var date = Date.parse(measurement.metadata.date);
              if (!(commit in commits) || date < commits[commit]) {
                commits[commit] = date;
              }

              Object.keys(measurement.measurements).forEach(function(type) {
                var value = measurement.measurements[type];
                measurement_types[type] = true;

                data_by_key[branch][type][benchmark][argv][host][commit] = value;
              });
            }
          });
        });
      });

      return {
        branches: Object.keys(branches).sort(),
        measurement_types: Object.keys(measurement_types).sort(),
        benchmarks: Object.keys(benchmarks).sort(),
        argvs: Object.keys(argvs).sort(),
        hosts: Object.keys(hosts).sort(),
        commits: Object.keys(commits).sort(function(a, b) {
          return commits[a] - commits[b];
        }),
        index: data_by_key,
      };
    }

    var make_dataset_label = function(selection, branch, type, benchmark, argv, host) {
      var label = [];
      if (selection.branches.length > 1) {
        label.push(branch);
      }
      if (selection.measurement_types.length > 1) {
        label.push(type);
      }
      if (selection.benchmarks.length > 1) {
        label.push(benchmark);
      }
      if (selection.argvs.length > 1) {
        label.push(argv);
      }
      if (selection.hosts.length > 1) {
        label.push(host);
      }

      return label.join(" / ");
    }

    // Uses the data index and current selection to generate datasets.
    var filter_datasets = function(data, selection) {
      // Compute which commits are actually used in this selection.
      var commits_used = {};
      selection.branches.forEach(function(branch) {
        selection.measurement_types.forEach(function(type) {
          selection.benchmarks.forEach(function(benchmark) {
            selection.argvs.forEach(function(argv) {
              selection.hosts.forEach(function(host) {
                data.commits.forEach(function(commit) {
                  if (commit in data.index[branch][type][benchmark][argv][host]) {
                    commits_used[commit] = true;
                  }
                });
              });
            });
          });
        });
      });

      // Use round-robin assignment for colors.
      var colors = [
        'rgba(255,99,132,1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      var color_count = colors.length;
      var color_i = 0;

      // Compute datasets.
      var datasets = [];
      selection.branches.forEach(function(branch) {
        selection.measurement_types.forEach(function(type) {
          selection.benchmarks.forEach(function(benchmark) {
            selection.argvs.forEach(function(argv) {
              selection.hosts.forEach(function(host) {
                var has_values = false;
                var values = [];
                data.commits.forEach(function(commit) {
                  if (commit in commits_used) {
                    has_values = true;
                    values.push(data.index[branch][type][benchmark][argv][host][commit]);
                  }
                });

                if (has_values) {
                  var color = colors[color_i];
                  color_i = (color_i + 1) % color_count;

                  var dataset = {
                    label: make_dataset_label(selection, branch, type, benchmark, argv, host),
                    data: values,
                    fill: false,
                    pointRadius: 7,
                    pointHoverRadius: 10,
                    backgroundColor: color,
                    borderColor: color,
                    borderWidth: 3,
                  }
                  datasets.push(dataset);
                }
              });
            });
          });
        });
      });

      var labels = data.commits.filter(function(commit) {
        return commit in commits_used;
      }).map(function(commit) {
        return commit.substring(0, 7);
      });

      return {
        labels: labels,
        datasets: datasets,
      };
    }

    var get_measurement_types = function(data) {
      var commits = Object.keys(data.measurements);
      var measurements = data.measurements;

      var measurement_types = [];
      var measurement_types_seen = {};

      commits.forEach(function(commit) {
        measurements[commit].forEach(function(measurement) {
          Object.keys(measurement.measurements).forEach(function(type) {
            if (!measurement_types_seen[type]) {
              measurement_types_seen[type] = true;
              measurement_types.push(type);
            }
          });
        });
      });

      return measurement_types;
    };

    var clear_select_options = function(select) {
      for (var i = select.options.length - 1 ; i >= 0 ; i--) {
        select.remove(i);
      }
    };

    var add_select_options = function(select, labels) {
      labels.forEach(function(label) {
        var option = document.createElement("option");
        option.text = label;
        select.add(option);
      });
    };

    var make_branch_picker = function(json_data, current) {
      var branches = json_data.branches;
      var current_i = branches.indexOf(current);

      var branch_picker = document.getElementById("branch");
      clear_select_options(branch_picker);
      add_select_options(branch_picker, branches);
      branch_picker.selectedIndex = current_i;
      branch_picker.disabled = false;
      branch_picker.addEventListener(
        "change",
        function() {
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type_picker = document.getElementById("measurement_type");
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var make_measurement_type_picker = function(json_data, current) {
      var measurement_types = get_measurement_types(json_data);
      var current_i = measurement_types.indexOf(current);

      var measurement_type_picker = document.getElementById("measurement_type");
      clear_select_options(measurement_type_picker);
      add_select_options(measurement_type_picker, measurement_types);
      measurement_type_picker.selectedIndex = current_i;
      measurement_type_picker.disabled = false;
      measurement_type_picker.addEventListener(
        "change",
        function() {
          var branch_picker = document.getElementById("branch");
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var initialize = function(json_data) {
      // Right now just render the master branch and execution time.
      var branch = "master";
      var measurement_type = "time_seconds";

      var data_index = build_data_index(json_data);
      var selection = {
        branches: [branch],
        measurement_types: [measurement_type],
        benchmarks: data_index.benchmarks,
        argvs: data_index.argvs,
        hosts: data_index.hosts,
      };
      var chart_data = filter_datasets(data_index, selection);

      make_line_chart(chart_data);
      make_branch_picker(json_data, branch);
      make_measurement_type_picker(json_data, measurement_type);

    };

    getJSON("https://raw.githubusercontent.com/StanfordLegion/perf-data/master/rendered/chart.json",
      function(err, data) {
        if (err != null) {
          alert("Error: " + err);
        } else {
          initialize(data);
        }
      });

    </script>
  </body>
</html>
