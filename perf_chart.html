<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <title>Legion Performance Testing</title>
  </head>
  <body>

    <div style="width: 100%; height: 450px;">
      <!-- Div is here to avoid reflow when canvas resizes -->
      <canvas id="chart" width="400" height="400"></canvas>
    </div>
    <label for="branch">Branch:</label>
    <select id="branch" disabled><option value="loading">Loading...</option></select>
    <label for="measurement_type">Measurement:</label>
    <select id="measurement_type" disabled><option value="loading">Loading...</option></select>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/2.5.0/Chart.bundle.min.js"></script>
    <script>
    // A Python defaultdict style map object
    var defaultdict = function(constructor) {
      return new Proxy({}, {
        get: function(target, property) {
          if (!(property in target)) {
            var value = constructor();
            target[property] = value;
          }
          return target[property];
        },
      });
    };

    // Utility function to fetch JSON.
    var getJSON = function(url, callback) {
      var xhr = new XMLHttpRequest();
      xhr.open("get", url, true);
      xhr.responseType = "json";
      xhr.onload = function() {
        var status = xhr.status;
        if (status == 200) {
          callback(null, xhr.response);
        } else {
        callback(status);
        }
      };
      xhr.send();
    };

    var make_line_chart = function(data) {
      var ctx = document.getElementById("chart");
      window.line_chart = new Chart(ctx, {
        type: "line",
        data: data,
        options: {
          responsive: true,
          maintainAspectRatio: false,
          legend: {
            position: "left",
          },
        },
      });
    };

    var update_line_chart_data = function(data) {
      window.line_chart.config.data = data;
      window.line_chart.update();
    };

    // Generate chart data from measurements.
    var get_measurement_data = function(data, branch, measurement_type) {
      var commits = data["commits"][branch];
      var measurements = data["measurements"];
      var data_by_benchmark_argv_host_commit = defaultdict(function() {
        return defaultdict(function() {
          return defaultdict(function() { return []; });
        });
      });

      var benchmarks = [];
      var argv_by_benchmark = defaultdict(function() { return []; });
      var host_by_benchmark_argv = defaultdict(function() {
        return defaultdict(function() { return []; });
      });

      commits.forEach(function(commit) {
        measurements[commit].forEach(function(measurement) {
          if (measurement["metadata"]["branch"] == branch) {
            var benchmark = measurement["metadata"]["benchmark"];
            var argv = measurement["metadata"]["argv"];
            var host = measurement["metadata"]["host"];

            if (!(benchmark in data_by_benchmark_argv_host_commit)) {
              benchmarks.push(benchmark);
            }
            if (!(argv in data_by_benchmark_argv_host_commit[benchmark])) {
              argv_by_benchmark[benchmark].push(argv);
            }
            if (!(host in data_by_benchmark_argv_host_commit[benchmark][argv])) {
              host_by_benchmark_argv[benchmark][argv].push(host);
            }
            // FIXME: If there are multiple matching entries, this
            // will just pick one. Would be nice to take a mean or
            // something.
            data_by_benchmark_argv_host_commit[benchmark][argv][host][commit] =
              measurement["measurements"][measurement_type];
          }
        });
      });

      var colors = [
        'rgba(255,99,132,1)',
        'rgba(54, 162, 235, 1)',
        'rgba(255, 206, 86, 1)',
        'rgba(75, 192, 192, 1)',
        'rgba(153, 102, 255, 1)',
        'rgba(255, 159, 64, 1)'
      ];
      var color_count = colors.length;
      var color_i = 0;

      var datasets = [];
      benchmarks.forEach(function(benchmark) {
        argv_by_benchmark[benchmark].forEach(function(argv) {
          host_by_benchmark_argv[benchmark][argv].forEach(function(host) {
            var data = [];
            var measurements = data_by_benchmark_argv_host_commit[benchmark][argv][host];
            commits.forEach(function(commit) {
              data.push(measurements[commit]);
            });

            var color = colors[color_i];
            color_i = (color_i + 1) % color_count;

            var dataset = {
              label: benchmark + " / " + argv + " / " + host,
              data: data,
              fill: false,
              pointRadius: 7,
              pointHoverRadius: 10,
              backgroundColor: color,
              borderColor: color,
              borderWidth: 3,
            }
            datasets.push(dataset);
          });
        });
      });

      var labels = commits.map(function(commit) {
        return commit.substring(0, 7);
      });

      return {
        labels: labels,
        datasets: datasets,
      };
    };

    var get_measurement_types = function(data) {
      var commits = Object.keys(data["measurements"]);
      var measurements = data["measurements"];

      var measurement_types = [];
      var measurement_types_seen = {};

      commits.forEach(function(commit) {
        measurements[commit].forEach(function(measurement) {
          Object.keys(measurement["measurements"]).forEach(function(type) {
            if (!measurement_types_seen[type]) {
              measurement_types_seen[type] = true;
              measurement_types.push(type);
            }
          });
        });
      });

      return measurement_types;
    };

    var clear_select_options = function(select) {
      for (var i = select.options.length - 1 ; i >= 0 ; i--) {
        select.remove(i);
      }
    };

    var add_select_options = function(select, labels) {
      labels.forEach(function(label) {
        var option = document.createElement("option");
        option.text = label;
        select.add(option);
      });
    };

    var make_branch_picker = function(json_data, current) {
      var branches = json_data["branches"];
      var current_i = branches.indexOf(current);

      var branch_picker = document.getElementById("branch");
      clear_select_options(branch_picker);
      add_select_options(branch_picker, branches);
      branch_picker.selectedIndex = current_i;
      branch_picker.disabled = false;
      branch_picker.addEventListener(
        "change",
        function() {
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type_picker = document.getElementById("measurement_type");
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var make_measurement_type_picker = function(json_data, current) {
      var measurement_types = get_measurement_types(json_data);
      var current_i = measurement_types.indexOf(current);

      var measurement_type_picker = document.getElementById("measurement_type");
      clear_select_options(measurement_type_picker);
      add_select_options(measurement_type_picker, measurement_types);
      measurement_type_picker.selectedIndex = current_i;
      measurement_type_picker.disabled = false;
      measurement_type_picker.addEventListener(
        "change",
        function() {
          var branch_picker = document.getElementById("branch");
          var branch = branch_picker.options[branch_picker.selectedIndex].text;
          var measurement_type = measurement_type_picker.options[measurement_type_picker.selectedIndex].text;
          var chart_data = get_measurement_data(json_data, branch, measurement_type);
          update_line_chart_data(chart_data);
        });
    };

    var initialize = function(json_data) {
      // Right now just render the master branch and execution time.
      var branch = "master";
      var measurement_type = "time_seconds";
      var chart_data = get_measurement_data(json_data, branch, measurement_type);
      make_line_chart(chart_data);
      make_branch_picker(json_data, branch);
      make_measurement_type_picker(json_data, measurement_type);
    };

    getJSON("https://raw.githubusercontent.com/StanfordLegion/perf-data/master/rendered/chart.json",
      function(err, data) {
        if (err != null) {
          alert("Error: " + err);
        } else {
          initialize(data);
        }
      });

    </script>
  </body>
</html>
